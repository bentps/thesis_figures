#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Tue Aug  8 16:39:35 2017

@author: hamavid
"""

import pandas as pd # imports the package that has a nice CSV reading function
import matplotlib.pyplot as plt
import numpy as np # imports numpy, which has a save to CSV function
import matplotlib.gridspec as gridspec
import os
from matplotlib.offsetbox import (OffsetImage, AnnotationBbox)

os.chdir('/Users/BenPS/Dropbox/Physics/Data') 

#set up the figure
fig = plt.figure(figsize=(4, 4)) #width, length
gs = gridspec.GridSpec(2, 1, wspace=0.0, hspace=0.4,
                               height_ratios=[3, 2]) #length, width
#panel a on the grid
pa_inner_grid = gridspec.GridSpecFromSubplotSpec(2, 1,
        subplot_spec=gs[0], wspace=-0.0, hspace=0.0, 
                               height_ratios=[10, 3])

#plt.subplots_adjust(bottom=0.05)

#####################
# SIGNAL
#####################
#This is a function that imports a .CSV generated by the scope, and turns it in to a pair of lists of the relevant columns.
def csv(x):
    datatable = pd.read_csv(x, names=['a','b']) 
    timebase=[i for i in datatable.a] #The dataframe is more complicated than wanted for current purposes, so this creates a simpler object called a list 
    signal=[i for i in datatable.b] #above line creats a list of column c, this line creates a list of column d.
    return timebase, signal #returns a "tuple" in the format (timebase, signal)

file_in='N1examplesignal.CSV'
timebase=np.array(csv(file_in)[0])
signal=np.array(csv(file_in)[1])


wave_signal=plt.Subplot(fig, gs[1])
wave_signal.plot(timebase, signal+0.03,color='Black')
totalwavetime=.00095
wave_signal.axis([0,totalwavetime,0,.5])
wave_signal.set_ylabel('PMT signal (V)',fontsize=10)
wave_signal.set_xlabel('Time (ms)',fontsize=10)
signallabels=np.array([0,.2,.4,.6,.8])
wave_signal.xaxis.set_ticklabels(signallabels) #signal is 1000 ms
#wave_signal.axvspan(totalwavetime/4, 3*totalwavetime/4, facecolor=violet, alpha=0.15) #readout is only the middle section
panellabel = wave_signal.twiny()
panellabel.set_xticks([])
panellabel.set_xticklabels([])
fig.add_subplot(wave_signal)


#####################
# BOUNCING LASERS
#####################
#actual physics things
hbar=1.0545718E-34 #joule seconds
hbarerror=0.000000013E-34 #joule seconds
mybu=173.938867539 #unified atomic mass units, from ed myer
u=1.660539040E-27 #unified atomic mass units in kg
myb=mybu*u
vs=539386841661000 #hz
c=299792458 #m / s
k=vs/c #1/m
omegarec=(2*np.pi*hbar*k**2)/(2*myb) #hz

#graph segment dimensions         
tend=300 #x dimension
xend=300 #y dimension

#parameters and functions to make sine pattern
t = np.linspace(0, .0001, tend, endpoint=True)  
x = np.linspace(0, 2E-6, xend, endpoint=True)  
xdenom=7
ydenom=7

def my_sint(t):
    phase=-np.pi/2
    amplitude=0 #1 for orig, 0 for no breaks
    offset=1
    return (np.sin(t*2*np.pi*4*2*omegarec + phase))*amplitude+offset

def my_sinx(x,amp):
    phase=1.4*np.pi
    amplitude=amp
    offset=0
    return (np.sin(x*2*np.pi/(556E-9/2) + phase))*amplitude+offset

interference=[]
for i in range(tend):
    row=np.array([my_sinx(x[j],my_sint(t[i])) for j in range(xend)])     
    interference.append(row)    
interference=np.array(interference)
interference=interference.transpose()


#vectors for laser lines/arrows
margin=10
thrux=[margin, tend-margin]
thruy=[xend-margin,margin]
bounceinx = [margin,tend/2]
bounceiny = [margin,xend/2]
bouncebackx = [tend/2,tend-margin]
bouncebacky = [xend/2, margin]

#arrow head specs
hl=65
hw=40
w=7
lw=1.5

#colors
lightgrey='#c7c7c7'
darkgrey='#969696'
violet='#5823f9'

#fringe/nofringe inset locations
nfloc=[.2, .25, .12, .075] #x,y of bottom left corner, width height, by axis pct
floc=[.75, .22, .12, .2] #but it doesn't seem to actually correspond to that

#no fringe
ax1 = plt.Subplot(fig, gs[1])
nofringe=plt.axes(nfloc) #,frameon=False 
nofringe.plot(thrux, thruy, linewidth=lw, color=violet)
nofringe.set_xlim([-xend/8,9*xend/8])
nofringe.set_ylim([-tend/8,9*tend/8])
nofringe.set_facecolor('white')
nofringe.axhspan(tend/ydenom, tend-tend/ydenom, facecolor=darkgrey, alpha=1)
nofringe.axvspan(-xend/8, xend/xdenom, facecolor='white', alpha=1)
nofringe.axvspan(xend-xend/xdenom, 9*xend/8, facecolor='white', alpha=1)
nofringe.arrow(margin, xend-margin, tend-margin, -xend+margin,
            width=w, color=violet, overhang=0.5, head_width=hw, head_length=hl, length_includes_head='TRUE')
nofringe.set_xticks([])
nofringe.set_yticks([])

#fringe
ax2 = plt.Subplot(fig, gs[1])
fringe=plt.axes(floc)
fringe.imshow(interference, cmap="Greys")
fringe.set_xlim([-xend/8,9*xend/8])
fringe.set_ylim([9*tend/8,-tend/8])
fringe.set_facecolor('white')
fringe.axhspan(0, tend/ydenom, facecolor='white', alpha=1)
fringe.axhspan(tend, tend-tend/ydenom, facecolor='white', alpha=1)
fringe.axvspan(-margin, xend/xdenom+margin, facecolor='white', alpha=1)
fringe.axvspan(xend-xend/xdenom, xend+margin, facecolor='white', alpha=1)
fringe.plot(bounceinx, bounceiny, linewidth=lw, color=violet)
fringe.plot(bouncebackx, bouncebacky, linewidth=lw, color=violet)
fringe.arrow(tend/2+margin, xend/2-margin, tend/2-margin, -xend/2+margin,
            width=w, color=violet, overhang=0.5, head_width=hw, head_length=hl, length_includes_head='TRUE')
fringe.set_xticks([])
fringe.set_yticks([])

###################
# connectors
###################
nfxb=totalwavetime*np.array([0.1,0.45]) # 'no fringe x bottom' line coords
nfyb=0.5*np.array([0.49,0.06])
nfxt=totalwavetime*np.array([0.253,0.45])
nfyt=0.5*np.array([0.78,0.06])
fxb=totalwavetime*np.array([0.69,0.96])
fyb=0.5*np.array([0.41,0.62])
fxt=totalwavetime*np.array([0.69,0.806])
fyt=0.5*np.array([0.41,0.91])
wave_signal.plot(nfxb, nfyb, linewidth=1, ls='--', color='black')
wave_signal.plot(nfxt, nfyt, linewidth=1, ls='--', color='black')
wave_signal.plot(fxb, fyb, linewidth=1, ls='--', color='black')
wave_signal.plot(fxt, fyt, linewidth=1, ls='--', color='black')

#panel labels
#wave_signal.set_xlabel('Panel B                                                                             ')
#wave_signal.xaxis.set_label_position('top')    
wave_signal.annotate('(b)', xy=(0,0.515), xytext=(0,0.515), xycoords='data', annotation_clip=False)
  

###############################
######## PANEL A ##############
###############################
#define speeds and directions that atoms can go
def middle(x):
    y=0*x
    return y

def base(x):
    y=x
    return y

def four(x):
    y=4*x
    return y

def negbase(x):
    y=-x
    return y

def negfour(x):
    y=-4*x
    return y

#define the time-spans of the various stages of atom-activities
stem=-.0250
warmup1=.500 + .065
warmup2=.500 + .130 + .065
speedy=.065 + .130 + 1.000  + .065
less1=.065 + .130 + .065
less2=.065 + .065
turn1=.065 + .065
turn2=.065 + .130 + .065
brakes=.065 + .130 + 1.000 + .065
warmdown1=.065 + .130 + .500
warmdown2=.065 + .500

#how long are the atoms going for? how many points to plot lines along?
z=np.linspace(stem-.3,5.100,3000)

#define the times at which atom-speeds change
a=stem+warmup1
b=a+speedy
c=b+less1
d=c+turn1
e=d+brakes
f=e+warmdown1

g=stem+warmup2
h=g+speedy
i=h+less2
j=i+turn2
k=j+brakes
l=k+warmdown2

#define where the atoms are when they change speed corresponding to each change-time
chng=stem
chnga=base(a)-chng
chngb=four(b)-(four(a)-chnga)
chngc=base(c)-(base(b)-chngb)
chngd=negbase(d)-(negbase(c)-chngc)
chnge=negfour(e)-(negfour(d)-chngd)

chngg=negbase(g)+chng
chngh=negfour(h)-(negfour(g)-chngg)
chngi=negbase(i)-(negbase(h)-chngh)
chngj=base(j)-(base(i)-chngi)
chngk=four(k)-(four(j)-chngj)


#lay out each path of atoms by which direction they start going at the first pulse
def top(x):
    y=np.piecewise(
        x, [(x>=stem) & (x<a),(x>=a) & (x<b),(x>=b) & (x<c),
        (x>=c) & (x<d),(x>=d) & (x<e),x>=e],
        [lambda x: base(x)-chng, 
        lambda x: four(x)-(four(a)-chnga), 
        lambda x: base(x)-(base(b)-chngb),
        lambda x: negbase(x)-(negbase(c)-chngc), 
        lambda x: negfour(x)-(negfour(d)-chngd),
        lambda x: negbase(x)-(negbase(e)-chnge)]
    )
    return y

def bottom(x):
    y=np.piecewise(
        x, [(x>=stem) & (x<g),(x>=g) & (x<h),(x>h) & (x<i),
        (x>=i) & (x<j),(x>=j) & (x<k),x>=k],
        [lambda x: negbase(x)+chng, 
        lambda x: negfour(x)-(negfour(g)-chngg), 
        lambda x: negbase(x)-(negbase(h)-chngh),
        lambda x: base(x)-(base(i)-chngi), 
        lambda x: four(x)-(four(j)-chngj),
        lambda x: base(x)-(base(k)-chngk)]
    )
    return y
    

# the x,y values of the change-points just in case
points = np.array([
    [stem,middle(stem)],
    [a,chnga],
    [b,chngb],
    [c,chngc],
    [d,chngd],
    [e,chnge],
    [f,middle(f)],
    [g,chngg],
    [h,chngh],
    [i,chngi],
    [j,chngj],
    [k,chngk],
    [l,middle(l)]
])
x, y = points.T

#define the pulses as functions
def pulse(x, phase, amp, period):
    y=amp*(np.cos(2*np.pi*x/period+phase)+1)
    return y  
 
def phase(x, period):
    phase=-2*np.pi*x/period-np.pi
    return phase

def null(x):
    pass

#piecewise functions for the pulses at their times
def toppulses(x):
    y=np.piecewise(
        x, [x<s1, (x>=s1) & (x<=s1+onepulse), (x>s1+onepulse) & (x<s2), (x>=s2) & (x<=s2+onepulse),
            (x>s2+onepulse) & (x<s3), (x>=s3) & (x<=s3+onepulse), (x>s3+onepulse) & (x<s4),
            (x>=s4) & (x<=s4+onepulse), x>s4+onepulse],
        [lambda x: null(x),
        lambda x: pulse(x, phase(s1, onepulse),1, onepulse),
        lambda x: null(x), 
        lambda x: pulse(x, phase(s2, onepulse),1, onepulse),
        lambda x: null(x),
        lambda x: pulse(x, phase(s3, onepulse),1, onepulse),
        lambda x: null(x),
        lambda x: pulse(x, phase(s4, onepulse),1, onepulse),
        lambda x: null(x)]
    )
    return y

def bottompulses(x):
    y=np.piecewise(
        x, [x<s1+onepulse, (x>=s1+onepulse) & (x<=s1+twopulses), (x>s1+twopulses) & (x<s2+onepulse),
            (x>=s2+onepulse) & (x<=s2+twopulses), (x>s2+twopulses) & (x<s3+onepulse),
            (x>=s3+onepulse) & (x<=s3+twopulses), (x>s3+twopulses) & (x<s4+onepulse),
            (x>=s4+onepulse) & (x<=s4+twopulses), x>s4+twopulses],
        [lambda x: null(x),
        lambda x: pulse(x, phase(s1, onepulse),1, onepulse),
        lambda x: null(x), 
        lambda x: pulse(x, phase(s2, onepulse),1, onepulse),
        lambda x: null(x),
        lambda x: pulse(x, phase(s3, onepulse),1, onepulse),
        lambda x: null(x),
        lambda x: pulse(x, phase(s4, onepulse),1, onepulse),
        lambda x: null(x)]
    )
    return y

def midpulse(x):
    y=np.piecewise(
        x, [x<mid, (x>=mid) & (x<=mid+onepulse), x>mid+onepulse],
        [lambda x: null(x),
        lambda x: pulse(x, phase(mid, onepulse), 0.5, onepulse),
        lambda x: null(x)]
    )
    return y

def initialpulse(x):
    y=np.piecewise(
        x, [x<stem, (x>=stem) & (x<=stem+initial), x>stem+initial],
        [lambda x: null(x),
        lambda x: pulse(x, phase(stem-initial, initial), 0.5, initial),
        lambda x: null(x)]
    )
    return y

def readout(x):
    y=np.piecewise(
        x, [x<f-ropulse/2, (x>f-ropulse/2) & (x<f+ropulse/2), x>f+ropulse/2],
        [lambda x: null(x),
        lambda x: 1,
        lambda x: null(x)]
    )
    return y
 
#define pulse-set lengths and start times
initial=.050
onepulse=.130
twopulses=.260
ropulse=.500

s1=stem + .500
s2=s1 + twopulses + 1.000
mid=s2 + twopulses
s3=mid + onepulse
s4=s3 + twopulses + 1.000

#tweakable feats
atomlines = 2.5
pulselines = 1

#add atoms and pulses graphs
atoms = plt.Subplot(fig, pa_inner_grid[0])
puls = plt.Subplot(fig, pa_inner_grid[1])
fig.add_subplot(atoms)
fig.add_subplot(puls)

#plot the atoms' paths
atoms.plot(z,top(z),linewidth=atomlines, color='steelblue')
atoms.plot(z,bottom(z),linewidth=atomlines, color='#f87217')
atoms.plot(z,middle(z),linewidth=atomlines, color='black')

#plot the pulses
puls.plot(z,toppulses(z),linewidth=pulselines, color='green')
puls.plot(z,bottompulses(z),linewidth=pulselines, color='green')
puls.plot(z,midpulse(z),linewidth=pulselines, color='green')
puls.plot(z,initialpulse(z),linewidth=pulselines, color='green')
puls.plot(z,readout(z),linewidth=pulselines,color=violet)

#specify axis and tick visibility, label axes, control gap between plot
#puls.spines['top'].set_visible(False)
atoms.tick_params(bottom='off')
atoms.axes.get_xaxis().set_ticks([])
puls.set_xlabel('Time (ms)')
atoms.set_ylabel('Distance')
puls.set_ylabel('Intensity')
puls.yaxis.labelpad = 12
plt.subplots_adjust(hspace=-0.1)


#extremely hacky arrow situation
ahl=0.09
ahw=0.6
aw=0.015
yval=-6.5
puls.arrow(a+1.5*onepulse,3,speedy-twopulses-ahl,0,
            width=aw, color='k', overhang=0.5, head_width=ahw, head_length=ahl)
puls.arrow(b-onepulse/2,3,-speedy+twopulses+ahl,0,
            width=aw, color='k', overhang=0.5, head_width=ahw, head_length=ahl)
atoms.arrow(a+1.5*onepulse,yval,speedy-twopulses-ahl,0,
            width=aw, color='k', overhang=0.5, head_width=ahw, head_length=ahl)
atoms.arrow(b-onepulse/2,yval,-speedy+twopulses+ahl,0,
            width=aw, color='k', overhang=0.5, head_width=ahw, head_length=ahl)
puls.arrow(d+1.5*onepulse,3,speedy-twopulses-ahl,0,
            width=aw, color='k', overhang=0.5, head_width=ahw, head_length=ahl)
puls.arrow(e-onepulse/2,3,-speedy+twopulses+ahl,0,
            width=aw, color='k', overhang=0.5, head_width=ahw, head_length=ahl)
atoms.arrow(d+1.5*onepulse,yval,speedy-twopulses-ahl,0,
            width=aw, color='k', overhang=0.5, head_width=ahw, head_length=ahl)
atoms.arrow(e-onepulse/2,yval,-speedy+twopulses+ahl,0,
            width=aw, color='k', overhang=0.5, head_width=ahw, head_length=ahl)


#force x axes to be equal
puls.axis([stem-0.3,5.100+stem-.3,-0,3])
atoms.axis([stem-0.3,5.100+stem-.3,-6.500,6.500])

#add anotations, and remove tick labels:
puls.yaxis.set_ticklabels([])

atoms.text(1.18, -6, 'T')
atoms.text(2.83, -6, 'T')
atoms.text(1.1, -2, '3',color='#f87217')
atoms.text(1.1, .4, '2')
atoms.text(1.1, 3.5, '1',color='steelblue')
atoms.yaxis.set_ticklabels([])


#add vertical colored background areas and dotted lines to visually connect pulses w atoms
figures=[atoms,puls]
for s in [s1,s2,s3,s4]:
    currentrange=np.linspace(s,s+onepulse,500)
    atoms.fill_between(currentrange, -6.500,top(currentrange), facecolor='#e2eef9')
    puls.fill_between(currentrange, 0,3, facecolor='#e2eef9')
    currentrange=np.linspace(s+onepulse,s+twopulses,500)
    atoms.fill_between(currentrange, -6.500,bottom(currentrange), facecolor='#ffa07a', alpha=0.4)
    puls.fill_between(currentrange, 0,3, facecolor='#ffa07a', alpha=0.4)

for fi in figures:
    fi.axvspan(stem, stem+initial, facecolor='black', alpha=0.2)
    fi.axvspan(mid, mid+onepulse, facecolor='black', alpha=0.2)
    fi.axvspan(f-ropulse/2, f+ropulse/2, facecolor=violet, alpha=0.15)         

#add vertical lines up to readoutpulse
for xvalue in [f-ropulse/2, f+ropulse/2]:
    puls.vlines(x=xvalue, ymin=0, ymax=1, linewidth=1, color=violet)
    
#panel label
atoms.set_xlabel('(a)                                                                   ')
atoms.xaxis.set_label_position('top')    
    
##########################################

#save pdf
plt.savefig('insets_2panels.pdf')
